<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CubeZilla Solver</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
  <style>
    :root {
      --bg-main: #020617;
      --bg-panel: #0b1120;
      --accent-primary: #6366f1;
      --accent-glow: #8b5cf6;
      --accent-soft: #a5b4fc;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      width: 100%; height: 100vh; background: var(--bg-main);
      font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      color: var(--text-main); overflow: hidden; touch-action: none;
    }
    #overlay, #tutorial-modal {
      position: fixed; inset: 0; display: flex; justify-content: center; align-items: center;
      background: rgba(2,6,23,0.96); z-index: 100; padding: 20px;
    }
    .page, #tutorial-content {
      background: linear-gradient(145deg, rgba(15,23,42,0.96), rgba(15,23,42,0.92));
      padding: 40px; border-radius: 26px; max-width: 480px; width: 90vw;
      border: 1px solid rgba(148,163,184,0.4); box-shadow: 0 30px 80px rgba(0,0,0,0.9);
    }
    h1, h2 { background: linear-gradient(135deg, #e5e7eb, #a5b4fc); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
    .pop-btn {
      padding: 12px 26px; background: linear-gradient(135deg, var(--accent-primary), var(--accent-glow));
      color: white; border: none; border-radius: 999px; cursor: pointer; font-weight: 600;
      text-transform: uppercase; letter-spacing: 0.05em; box-shadow: 0 18px 40px rgba(59,130,246,0.45);
      transition: all 0.2s;
    }
    .pop-btn:hover { transform: translateY(-2px) scale(1.02); }
    #main-app { display: none; height: 100vh; grid-template-columns: 300px 1fr; }
    #sidebar { padding: 22px 20px; display: flex; flex-direction: column; gap: 16px; }
    #cube-container { position: relative; }
    #solve-info {
      position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
      padding: 8px 18px; background: rgba(15,23,42,0.95); border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.6); color: var(--text-muted); font-size: 0.8rem;
      opacity: 0; transition: opacity 0.3s; z-index: 10;
    }
    .camera-column { position: absolute; top: 50%; left: 24px; transform: translateY(-50%); gap: 12px; display: flex; flex-direction: column; }
    .camera-btn { width: 46px; height: 46px; background: #111827; color: #e5e7eb; border-radius: 14px; cursor: pointer; }
    .move-bar { position: absolute; bottom: 34px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; padding: 14px 16px; background: rgba(15,23,42,0.98); border-radius: 18px; }
    .move-btn { padding: 8px 10px; background: #0f172a; color: #e5e7eb; border-radius: 10px; cursor: pointer; }
    #paint-palette { position: absolute; bottom: 90px; right: 40px; display: none; flex-direction: column; gap: 10px; align-items: center; }
  </style>
</head>
<body>

<div id="overlay">
  <div class="page">
    <h1>CubeZilla Solver</h1>
    <p>A cinematic 3D Rubikâ€™s cube with touch, paint, and instant rewind solve.</p>
    <div style="display:flex; flex-direction:column; gap:12px; margin:20px 0;">
      <button class="pop-btn" id="start-btn">â–¶ Start</button>
      <button class="pop-btn" id="how-btn">? How it works</button>
      <button class="pop-btn" style="background:linear-gradient(135deg,#22c55e,#16a34a);" id="freeplay-btn">âš¡ Free-play</button>
      <button class="pop-btn" id="paint-btn">ðŸ§© Paint & Solve</button>
    </div>
    <div style="font-size:0.8rem; color:#9ca3af;">Credits: Anirudh Â· Madhav Â· Pratik â€¢ v1.0</div>
  </div>
</div>

<div id="main-app">
  <div id="sidebar">
    <h2>CONTROLS</h2>
    <button class="pop-btn" id="scramble-btn">Scramble</button>
    <button class="pop-btn" id="solve-btn">Solve</button>
    <button class="pop-btn" id="reset-btn">Reset Cube</button>
    <button class="pop-btn" id="reset-view-btn">Reset View</button>
    <button class="pop-btn" style="background:linear-gradient(135deg,#a855f7,#c084fc);" id="tutorial-btn">ðŸ“š Learn to Solve</button>
    <button class="pop-btn" style="background:#374151" id="back-btn">Back</button>
  </div>
  <div id="cube-container">
    <div id="solve-info"></div>
    <div class="camera-column">
      <button class="camera-btn" data-face="front">F</button>
      <button class="camera-btn" data-face="right">R</button>
      <button class="camera-btn" data-face="back">B</button>
      <button class="camera-btn" data-face="left">L</button>
      <button class="camera-btn" data-face="up">U</button>
      <button class="camera-btn" data-face="down">D</button>
    </div>
    <div class="move-bar">
      <button class="move-btn" data-move="R">R</button>
      <button class="move-btn" data-move="R_prime">R'</button>
      <button class="move-btn" data-move="L">L</button>
      <button class="move-btn" data-move="L_prime">L'</button>
      <button class="move-btn" data-move="U">U</button>
      <button class="move-btn" data-move="U_prime">U'</button>
      <button class="move-btn" data-move="F">F</button>
      <button class="move-btn" data-move="F_prime">F'</button>
    </div>
    <div id="paint-palette">
      <div style="display:flex; gap:8px;">
        <div data-color="U" style="width:24px;height:24px;border-radius:50%;background:#ffffff;cursor:pointer;"></div>
        <div data-color="D" style="width:24px;height:24px;border-radius:50%;background:#facc15;cursor:pointer;"></div>
        <div data-color="R" style="width:24px;height:24px;border-radius:50%;background:#ef4444;cursor:pointer;"></div>
        <div data-color="L" style="width:24px;height:24px;border-radius:50%;background:#f97316;cursor:pointer;"></div>
        <div data-color="F" style="width:24px;height:24px;border-radius:50%;background:#22c55e;cursor:pointer;"></div>
        <div data-color="B" style="width:24px;height:24px;border-radius:50%;background:#3b82f6;cursor:pointer;"></div>
      </div>
      <button class="pop-btn" id="solve-painted-btn">Start solving</button>
    </div>
  </div>
</div>

<div id="tutorial-modal" style="display:none;">
  <div id="tutorial-content">
    <h2>How to Solve a Rubikâ€™s Cube (Beginner Method)</h2>
    <ol>
      <li><strong>White Cross</strong> â€“ Align white edges with side centers</li>
      <li><strong>White Corners</strong> â€“ Complete white face</li>
      <li><strong>Middle Layer</strong> â€“ Place middle edges</li>
      <li><strong>Yellow Cross</strong> â€“ Form cross on top</li>
      <li><strong>Orient Yellow Edges</strong> â€“ Make full yellow cross</li>
      <li><strong>Position Yellow Corners</strong></li>
      <li><strong>Orient Yellow Corners</strong> â€“ Done!</li>
    </ol>
    <button class="pop-btn" id="close-tutorial-btn">Close</button>
  </div>
</div>

<script type="module">
class CubeZilla {
  constructor() {
    this.scene = null;
    this.camera = null;
    this.renderer = null;
    this.cubeGroup = null;
    this.inputCubeGroup = null;
    this.cubies = [];
    this.inputCubies = [];
    this.moveHistory = [];
    this.paintMode = false;
    this.currentPaintColor = 0xffffff;
    this.isRotating = false;
    this.isChangingView = false;
    this.currentView = { theta: 0, phi: 0.3 };
    this.zoomDistance = 12;
    this.paintStep = 0;

    this.paintGuide = [
      "Paint the cube to begin",
      "Step 1: White cross",
      "Step 2: White corners",
      "Step 3: Middle layer",
      "Step 4: Yellow cross",
      "Step 5: Orient yellow edges",
      "Step 6: Position yellow corners",
      "Step 7: Orient yellow corners â†’ Solved!"
    ];

    this.initEventListeners();
  }

  initEventListeners() {
    document.getElementById('start-btn').onclick = () => this.start();
    document.getElementById('freeplay-btn').onclick = () => this.start();
    document.getElementById('paint-btn').onclick = () => this.startPaintMode();
    document.getElementById('how-btn').onclick = () => this.showHow();
    document.getElementById('back-btn').onclick = () => location.reload();
    document.getElementById('scramble-btn').onclick = () => this.scramble();
    document.getElementById('solve-btn').onclick = () => this.solve();
    document.getElementById('reset-btn').onclick = () => location.reload();
    document.getElementById('reset-view-btn').onclick = () => this.snapTo('front');
    document.getElementById('tutorial-btn').onclick = () => document.getElementById('tutorial-modal').style.display = 'flex';
    document.getElementById('close-tutorial-btn').onclick = () => document.getElementById('tutorial-modal').style.display = 'none';
    document.getElementById('solve-painted-btn').onclick = () => alert('Painted cube ready â€“ solver coming soon!');

    document.querySelectorAll('.camera-btn').forEach(btn => {
      btn.onclick = () => this.snapTo(btn.dataset.face);
    });

    document.querySelectorAll('.move-btn').forEach(btn => {
      btn.onclick = () => this.performMove(btn.dataset.move);
    });

    document.querySelectorAll('#paint-palette > div > div').forEach(div => {
      div.onclick = () => this.selectColor(div.dataset.color);
    });
  }

  start() {
    document.getElementById('overlay').style.display = 'none';
    document.getElementById('main-app').style.display = 'grid';
    this.setup3D();
  }

  startPaintMode() {
    this.start();
    this.paintMode = true;
    this.cubeGroup.visible = false;
    this.inputCubeGroup.visible = true;
    document.getElementById('paint-palette').style.display = 'flex';
    this.paintStep = 0;
    this.setInfo(this.paintGuide[0]);
  }

  setup3D() {
    const container = document.getElementById('cube-container');
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(35, container.clientWidth / container.clientHeight, 0.1, 1000);
    this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    this.renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(this.renderer.domElement);

    this.scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    this.scene.add(new THREE.DirectionalLight(0xffffff, 0.8).position.set(3,5,4));

    this.cubeGroup = new THREE.Group();
    this.scene.add(this.cubeGroup);
    this.buildCube(this.cubeGroup, this.cubies, [0xff0000, 0xffa500, 0xffffff, 0xffff00, 0x00ff00, 0x0000ff], 1);

    this.inputCubeGroup = new THREE.Group();
    this.scene.add(this.inputCubeGroup);
    this.buildCube(this.inputCubeGroup, this.inputCubies, [0x374151,0x374151,0x374151,0x374151,0x374151,0x374151], 1.4);
    this.inputCubeGroup.position.set(-5,0,0);
    this.inputCubeGroup.visible = false;

    this.updateCamera();
    this.renderer.domElement.addEventListener('pointerdown', e => this.onPointerDown(e));
    this.renderer.domElement.addEventListener('pointermove', e => this.onPointerMove(e));
    this.renderer.domElement.addEventListener('pointerup', () => this.isDragging = false);

    this.animate();
  }

  buildCube(group, list, colors, scale = 1) {
    for (let x = -1; x <= 1; x++) for (let y = -1; y <= 1; y++) for (let z = -1; z <= 1; z++) {
      if (x===0 && y===0 && z===0) continue;
      const mats = colors.map(c => new THREE.MeshLambertMaterial({color: c}));
      const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.95,0.95,0.95), mats);
      mesh.position.set(x*scale, y*scale, z*scale);
      list.push(mesh);
      group.add(mesh);
    }
  }

  updateCamera() {
    this.camera.position.set(
      this.zoomDistance * Math.cos(this.currentView.phi) * Math.sin(this.currentView.theta),
      this.zoomDistance * Math.sin(this.currentView.phi),
      this.zoomDistance * Math.cos(this.currentView.phi) * Math.cos(this.currentView.theta)
    );
    this.camera.lookAt(0,0,0);
  }

  snapTo(face) {
    if (this.isChangingView) return;
    const views = {
      front: {t:0, p:0.3}, right: {t:-Math.PI/2, p:0.3}, back: {t:Math.PI, p:0.3},
      left: {t:Math.PI/2, p:0.3}, up: {t:0, p:-Math.PI/2+0.2}, down: {t:0, p:Math.PI/2-0.2}
    };
    this.isChangingView = true;
    gsap.to(this.currentView, {theta: views[face].t, phi: views[face].p, duration: 0.6, onUpdate: () => this.updateCamera(), onComplete: () => this.isChangingView = false});
  }

  performMove(move) {
    const prime = move.endsWith('_prime');
    const clean = move.replace('_prime', '');
    const dirs = {R:'right', L:'left', U:'up', D:'down', F:'front', B:'back'};
    const dir = dirs[clean];

    this.camera.updateMatrixWorld();
    const camRight = new THREE.Vector3().setFromMatrixColumn(this.camera.matrixWorld, 0).normalize();
    const camUp = new THREE.Vector3().setFromMatrixColumn(this.camera.matrixWorld, 1).normalize();
    const camForward = new THREE.Vector3().setFromMatrixColumn(this.camera.matrixWorld, 2).normalize().negate();

    let worldDir = new THREE.Vector3();
    if (dir === 'right') worldDir.copy(camRight);
    else if (dir === 'left') worldDir.copy(camRight).negate();
    else if (dir === 'up') worldDir.copy(camUp);
    else if (dir === 'down') worldDir.copy(camUp).negate();
    else if (dir === 'front') worldDir.copy(camForward);
    else if (dir === 'back') worldDir.copy(camForward).negate();

    const axes = [new THREE.Vector3(1,0,0), new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,1)];
    const dots = axes.map(a => Math.abs(worldDir.dot(a)));
    const max = Math.max(...dots);
    const idx = dots.indexOf(max);
    const axis = ['x','y','z'][idx];
    const sign = worldDir.dot(axes[idx]) > 0 ? 1 : -1;

    this.moveHistory.push(move);
    this.rotateLayer(axis, sign, prime);
  }

  rotateLayer(axis, sign, prime) {
    if (this.isRotating) return;
    this.isRotating = true;
    const pivot = new THREE.Group();
    this.cubeGroup.add(pivot);
    const moving = [];
    this.cubies.forEach(c => {
      if (Math.abs(c.position[axis] - sign) < 0.1) {
        pivot.attach(c);
        moving.push(c);
      }
    });
    const angle = (prime ? 1 : -1) * Math.PI / 2;
    gsap.to(pivot.rotation, {
      [axis]: '+=' + angle,
      duration: 0.18,
      ease: "power2.inOut",
      onComplete: () => {
        moving.forEach(c => {
          this.cubeGroup.attach(c);
          c.position.round();
        });
        this.scene.remove(pivot);
        this.isRotating = false;
      }
    });
  }

  scramble() {
    let count = 0;
    const moves = ['R','R_prime','L','L_prime','U','U_prime','F','F_prime'];
    const int = setInterval(() => {
      if (this.isRotating || this.isChangingView) return;
      if (count++ >= 40) { clearInterval(int); return; }
      this.performMove(moves[Math.floor(Math.random()*moves.length)]);
    }, 260);
  }

  solve() {
    if (this.moveHistory.length === 0) return;
    const reverse = this.moveHistory.slice().reverse().map(m => m.endsWith('_prime') ? m.replace('_prime','') : m + '_prime');
    document.getElementById('method-title').innerText = 'Solving...';
    this.setInfo('');

    let i = 0;
    const next = () => {
      if (i >= reverse.length) {
        this.moveHistory = [];
        document.getElementById('method-title').innerText = 'Solved!';
        setTimeout(() => document.getElementById('method-title').innerText = 'CONTROLS', 1500);
        return;
      }
      this.performMove(reverse[i++]);
      setTimeout(next, 180);
    };
    next();
  }

  selectColor(face) {
    const colors = {U:0xffffff, D:0xfacc15, R:0xef4444, L:0xf97316, F:0x22c55e, B:0x3b82f6};
    this.currentPaintColor = colors[face];
  }

  onPointerDown(e) {
    if (this.paintMode) {
      // paint logic...
      return;
    }
    this.isDragging = true;
    this.prevX = e.clientX || e.touches[0].clientX;
    this.prevY = e.clientY || e.touches[0].clientY;
  }

  onPointerMove(e) {
    if (!this.isDragging || this.isRotating || this.isChangingView) return;
    const x = e.clientX || (e.touches && e.touches[0].clientX);
    const y = e.clientY || (e.touches && e.touches[0].clientY);
    const dx = x - this.prevX;
    const dy = y - this.prevY;
    this.currentView.theta -= dx * 0.005;
    this.currentView.phi -= dy * 0.005;
    this.currentView.phi = Math.max(0.1, Math.min(Math.PI-0.1, this.currentView.phi));
    this.updateCamera();
    this.prevX = x;
    this.prevY = y;
  }

  setInfo(text) {
    const el = document.getElementById('solve-info');
    el.textContent = text;
    el.style.opacity = text ? 1 : 0;
  }

  showHow() {
    alert("CubeZilla is a beautiful 3D Rubikâ€™s cube with touch drag, paint mode, instant rewind solve, and step-by-step guidance. Enjoy!");
  }

  animate() {
    requestAnimationFrame(() => this.animate());
    this.renderer.render(this.scene, this.camera);
  }
}

new CubeZilla();
</script>
</body>
</html>
