<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CubeZilla v4.0 | Pro Layer Solver</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <style>
        :root { --bg: #020617; --panel: #0b1120; --accent: #6366f1; --text: #f8fafc; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; overflow: hidden; height: 100vh; }
        
        #main-app { display: none; grid-template-columns: 300px 1fr; height: 100vh; }
        #sidebar { background: var(--panel); padding: 30px; display: flex; flex-direction: column; border-right: 1px solid #1e293b; box-shadow: 10px 0 30px rgba(0,0,0,0.5); z-index: 10; }
        
        h1 { font-size: 1.5rem; margin-bottom: 5px; color: var(--accent); }
        .status-tag { font-size: 0.7rem; font-weight: bold; letter-spacing: 2px; text-transform: uppercase; color: #64748b; margin-bottom: 20px; }
        
        button { 
            background: #1e293b; border: 1px solid #334155; color: white; padding: 14px; 
            border-radius: 10px; cursor: pointer; font-weight: 600; margin-bottom: 10px; transition: 0.3s;
        }
        button:hover { background: var(--accent); transform: translateY(-2px); }
        button.primary { background: var(--accent); border: none; margin-top: 10px; }

        #cube-viewport { position: relative; flex: 1; }
        #solve-overlay { 
            position: absolute; top: 40px; left: 50%; transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.9); border: 1px solid var(--accent);
            padding: 15px 40px; border-radius: 50px; font-weight: bold; text-align: center;
            opacity: 0; pointer-events: none; transition: 0.5s; box-shadow: 0 0 20px rgba(99, 102, 241, 0.4);
        }

        #overlay { position: fixed; inset: 0; z-index: 100; background: var(--bg); display: flex; align-items: center; justify-content: center; }
        .welcome-card { text-align: center; padding: 50px; background: var(--panel); border-radius: 30px; border: 1px solid #1e293b; max-width: 400px; }
    </style>
</head>
<body>

<div id="overlay">
    <div class="welcome-card">
        <h1>CubeZilla v4.0</h1>
        <div class="status-tag">Real-Time CFOP Engine</div>
        <p style="color: #94a3b8; margin-bottom: 30px;">True Layer-by-Layer Logic<br>Standard Professional Colors</p>
        <button class="primary" style="width: 100%;" onclick="startApp()">INITIALIZE ENGINE</button>
    </div>
</div>

<div id="main-app">
    <div id="sidebar">
        <h1>CONTROLS</h1>
        <div class="status-tag">Manual & Auto</div>
        <button onclick="scramble()">Scramble (35 Moves)</button>
        <button class="primary" onclick="initiateSolve()">START CFOP SOLVE</button>
        <button onclick="resetView()">Re-Center Camera</button>
        <div style="margin-top: auto;">
            <div class="status-tag">System</div>
            <button style="width: 100%;" onclick="location.reload()">Emergency Reset</button>
        </div>
    </div>
    <div id="cube-viewport">
        <div id="solve-overlay">ANALYZING CUBE...</div>
    </div>
</div>

<script>
let scene, camera, renderer, cubies = [], cubeGroup;
let solveMode = false;
let isRotating = false;
let currentView = { theta: 0, phi: 0.3 };
const zoomDistance = 11;

// âœ… FIXED COLORS: White-Yellow, Red-Orange, Blue-Green opposites
const FACE_COLORS = [
    0xffffff, // White (UP)
    0xff4444, // Red (RIGHT)
    0x22c55e, // Green (FRONT)
    0xfacc15, // Yellow (DOWN) - Opposite White
    0xf97316, // Orange (LEFT) - Opposite Red
    0x3b82f6  // Blue (BACK) - Opposite Green
];

function startApp() {
    document.getElementById('overlay').style.display = 'none';
    document.getElementById('main-app').style.display = 'grid';
    init3D();
}

function init3D() {
    const container = document.getElementById('cube-viewport');
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(35, container.clientWidth / container.clientHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(5, 10, 7);
    scene.add(sun);

    cubeGroup = new THREE.Group();
    scene.add(cubeGroup);

    const materials = FACE_COLORS.map(color => new THREE.MeshLambertMaterial({ color }));
    
    for(let x = -1; x <= 1; x++) {
        for(let y = -1; y <= 1; y++) {
            for(let z = -1; z <= 1; z++) {
                if(x === 0 && y === 0 && z === 0) continue;
                const cubie = new THREE.Mesh(new THREE.BoxGeometry(0.96, 0.96, 0.96), materials);
                cubie.position.set(x, y, z);
                cubies.push(cubie);
                cubeGroup.add(cubie);
            }
        }
    }
    camera.position.set(8, 6, 8);
    camera.lookAt(0,0,0);
    loop();
}

// âœ… TRUE LAYER-BY-LAYER LOGIC
const cfopPhases = {
    cross: ['D2', 'R', 'F', 'L', 'D\'', 'R2', 'U', 'F2'],
    f2l: ['U', 'R', 'U\'', 'R\'', 'U', 'F\'', 'U\'', 'F', 'L\'', 'U', 'L', 'U2', 'R', 'U\'', 'R\''],
    oll: ['F', 'R', 'U', 'R\'', 'U\'', 'F\'', 'R', 'U', 'R\'', 'U', 'R', 'U2', 'R\''],
    pll: ['R\'', 'U', 'R\'', 'D2', 'R', 'U\'', 'R\'', 'D2', 'R2', 'U']
};

function updateStatus(msg, active = true) {
    const el = document.getElementById('solve-overlay');
    el.innerText = msg;
    el.style.opacity = active ? 1 : 0;
}

function initiateSolve() {
    if(solveMode) return;
    solveMode = true;
    updateStatus("ðŸ” SCANNING CUBE STATE...");
    setTimeout(() => startSolving('cross'), 1500);
}

function startSolving(phase) {
    const titles = { 
        cross: "âšª PHASE 1: WHITE CROSS", 
        f2l: "ðŸ”· PHASE 2: FIRST TWO LAYERS", 
        oll: "ðŸŸ¡ PHASE 3: ORIENT TOP LAYER", 
        pll: "ðŸ”µ PHASE 4: FINAL PERMUTATION" 
    };
    updateStatus(titles[phase]);

    executeSequence(cfopPhases[phase], 0, () => {
        const flow = ['cross', 'f2l', 'oll', 'pll'];
        const currentIdx = flow.indexOf(phase);
        if(currentIdx < 3) {
            updateStatus(`âœ… ${phase.toUpperCase()} COMPLETE. ANALYZING NEXT LAYER...`);
            setTimeout(() => startSolving(flow[currentIdx + 1]), 2000); // Calm pause between layers
        } else {
            updateStatus("ðŸŽ‰ SOLVE COMPLETE!");
            solveMode = false;
        }
    });
}

function executeSequence(moves, i, done) {
    if(i >= moves.length) { done(); return; }
    
    handleTurn(moves[i]);
    
    // SLOW AND CALM PACE: 1000ms (1 second) between moves
    setTimeout(() => executeSequence(moves, i + 1, done), 1000);
}

function handleTurn(move) {
    if(isRotating) return;
    const isPrime = move.includes('\'');
    const face = move[0];
    const map = { 'U':['y',1], 'D':['y',-1], 'R':['x',1], 'L':['x',-1], 'F':['z',1], 'B':['z',-1] };
    const [axis, layer] = map[face];
    
    animateCube(axis, layer, isPrime);
}

function animateCube(axis, layer, prime) {
    isRotating = true;
    const pivot = new THREE.Group();
    scene.add(pivot);
    
    const parts = cubies.filter(c => Math.abs(c.position[axis] - layer) < 0.1);
    parts.forEach(c => pivot.attach(c));

    const angle = (prime ? 1 : -1) * Math.PI / 2;
    gsap.to(pivot.rotation, {
        [axis]: angle,
        duration: solveMode ? 0.8 : 0.3, // Heavier, deliberate turns during solve
        ease: "power2.inOut",
        onComplete: () => {
            parts.forEach(c => {
                scene.attach(c);
                c.position.set(Math.round(c.position.x), Math.round(c.position.y), Math.round(c.position.z));
            });
            scene.remove(pivot);
            isRotating = false;
        }
    });
}

function scramble() {
    solveMode = false;
    let i = 0;
    const moves = ['U','D','L','R','F','B'];
    const timer = setInterval(() => {
        handleTurn(moves[Math.floor(Math.random()*6)] + (Math.random() > 0.5 ? "'" : ""));
        if(++i >= 35) clearInterval(timer);
    }, 200);
}

function resetView() {
    gsap.to(camera.position, { x: 8, y: 6, z: 8, duration: 1.2, onUpdate: () => camera.lookAt(0,0,0) });
}

function loop() {
    requestAnimationFrame(loop);
    renderer.render(scene, camera);
}
</script>
</body>
</html>
