<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CubeZilla v5.0 | Complete Optimal Solver</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cubejs@0.4.1/cube.min.js"></script>
    <style>
        :root {
            --bg-main: #020617;
            --accent-primary: #6366f1;
            --text-main: #e5e7eb;
            --text-muted: #9ca3af;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: var(--bg-main); color: var(--text-main); font-family: sans-serif; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
        #overlay { position: fixed; inset: 0; background: rgba(2,6,23,0.96); display: flex; align-items: center; justify-content: center; z-index: 100; }
        .page { background: #0f172a; padding: 40px; border-radius: 26px; text-align: center; box-shadow: 0 0 40px rgba(99,102,241,0.4); max-width: 480px; }
        .pop-btn { padding: 14px 28px; background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; border: none; border-radius: 999px; cursor: pointer; font-weight: 600; margin: 5px; }
        #controls { padding: 20px; background: #0b1120; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        #container { flex: 1; position: relative; }
        #info { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(15,23,42,0.9); padding: 10px 20px; border-radius: 999px; border: 1px solid #6366f1; opacity: 0; transition: opacity 0.3s; z-index: 10; color: var(--text-muted); }
        .camera-column { position: absolute; left: 20px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 10px; }
        .camera-btn { background: #1e293b; color: white; border: 1px solid #334155; padding: 10px; border-radius: 10px; cursor: pointer; width: 50px; }
        .move-bar { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 5px; background: rgba(15,23,42,0.9); padding: 10px; border-radius: 20px; border: 1px solid #6366f1; }
        .move-btn { background: #1e293b; color: white; border: 1px solid #334155; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.9rem; }
    </style>
</head>
<body>

<div id="overlay">
    <div class="page">
        <h1>CubeZilla v5.0 Complete</h1>
        <p>Full optimal solver with 3D cube. Click to load.</p>
        <button class="pop-btn" onclick="startApp()">Start</button>
    </div>
</div>

<div id="container"></div>
<div id="controls">
    <button class="pop-btn" onclick="scramble()">Scramble</button>
    <button class="pop-btn" onclick="solveCube()">Solve Optimal</button>
    <button class="pop-btn" onclick="resetCube()">Reset</button>
</div>
<div id="info">Loading...</div>

<div class="camera-column">
    <button class="camera-btn" onclick="snapAndReorient('front')">F</button>
    <button class="camera-btn" onclick="snapAndReorient('right')">R</button>
    <button class="camera-btn" onclick="snapAndReorient('back')">B</button>
    <button class="camera-btn" onclick="snapAndReorient('left')">L</button>
    <button class="camera-btn" onclick="snapAndReorient('up')">U</button>
    <button class="camera-btn" onclick="snapAndReorient('down')">D</button>
</div>
<div class="move-bar">
    <button class="move-btn" onclick="screenMove('R')">R</button>
    <button class="move-btn" onclick="screenMove('R_prime')">R'</button>
    <button class="move-btn" onclick="screenMove('L')">L</button>
    <button class="move-btn" onclick="screenMove('L_prime')">L'</button>
    <button class="move-btn" onclick="screenMove('U')">U</button>
    <button class="move-btn" onclick="screenMove('U_prime')">U'</button>
    <button class="move-btn" onclick="screenMove('F')">F</button>
    <button class="move-btn" onclick="screenMove('F_prime')">F'</button>
</div>

<script>
    let scene, camera, renderer, cubeGroup, cubies = [];
    let isRotating = false, isChangingView = false, solveMode = false;
    let currentView = { theta: -0.8, phi: 0.6 };
    const zoomDistance = 12;
    let moveQueue = [];
    let cubeInstance;

    const FACE_COLORS = [0xffffff, 0xff4444, 0x22c55e, 0xfacc15, 0xf97316, 0x3b82f6]; // U R F D L B

    function startApp() {
        document.getElementById('overlay').style.display = 'none';
        if (typeof Cube === 'undefined') {
            document.getElementById('info').textContent = 'Solver library failed to load. Basic cube only.';
            document.getElementById('info').style.opacity = 1;
        } else {
            cubeInstance = new Cube();
            Cube.initSolver();
            document.getElementById('info').textContent = 'Solver ready.';
            document.getElementById('info').style.opacity = 1;
            setTimeout(() => document.getElementById('info').style.opacity = 0, 2000);
        }
        setup3D();
    }

    function setup3D() {
        const container = document.getElementById('container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020617);

        camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambient);
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 10, 7);
        scene.add(light);

        cubeGroup = new THREE.Group();
        scene.add(cubeGroup);

        const materials = FACE_COLORS.map(color => new THREE.MeshLambertMaterial({ color }));

        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    if (x === 0 && y === 0 && z === 0) continue;
                    const cubie = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.95, 0.95), materials);
                    cubie.position.set(x, y, z);
                    cubies.push(cubie);
                    cubeGroup.add(cubie);
                }
            }
        }

        updateCamera();
        window.addEventListener('resize', onWindowResize);
        animate();
    }

    function onWindowResize() {
        const container = document.getElementById('container');
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }

    function updateCamera() {
        camera.position.set(
            zoomDistance * Math.cos(currentView.phi) * Math.sin(currentView.theta),
            zoomDistance * Math.sin(currentView.phi),
            zoomDistance * Math.cos(currentView.phi) * Math.cos(currentView.theta)
        );
        camera.lookAt(0, 0, 0);
    }

    function snapAndReorient(target) {
        if (isChangingView || isRotating) return;
        isChangingView = true;
        const views = {
            front: { theta: 0, phi: 0.3 },
            right: { theta: -Math.PI/2, phi: 0.3 },
            back: { theta: Math.PI, phi: 0.3 },
            left: { theta: Math.PI/2, phi: 0.3 },
            up: { theta: 0, phi: -Math.PI/2 + 0.2 },
            down: { theta: 0, phi: Math.PI/2 - 0.2 }
        };
        const v = views[target] || views.front;
        gsap.to(currentView, {
            theta: v.theta, phi: v.phi, duration: 1, ease: "power2.inOut",
            onUpdate: updateCamera,
            onComplete: () => isChangingView = false
        });
    }

    function handleMove(axis, layer, clockwise = true) {
        if (isRotating) return;
        isRotating = true;
        const pivot = new THREE.Group();
        cubeGroup.add(pivot);

        const moving = cubies.filter(c => Math.round(c.position[axis]) === layer);
        moving.forEach(c => pivot.attach(c));

        const angle = clockwise ? Math.PI / 2 : -Math.PI / 2;
        const duration = solveMode ? 0.8 : 0.4;
        gsap.to(pivot.rotation, {
            [axis]: gsap.utils.interpolate(pivot.rotation[axis], pivot.rotation[axis] + angle, 1),
            duration,
            ease: "power2.inOut",
            onComplete: () => {
                moving.forEach(c => {
                    cubeGroup.attach(c);
                    c.position.set(Math.round(c.position.x), Math.round(c.position.y), Math.round(c.position.z));
                });
                cubeGroup.remove(pivot);
                isRotating = false;
                if (solveMode && moveQueue.length > 0) {
                    setTimeout(executeNextMove, 200);
                }
            }
        });
    }

    function executeNextMove() {
        if (moveQueue.length === 0 || isRotating) return;
        const move = moveQueue.shift();
        performMove(move);
    }

    function performMove(notation) {
        if (!notation) return;
        const two = notation.includes('2');
        const prime = notation.includes("'");
        const face = notation.replace(/['2]/g, '');
        const map = { U: ['y', 1], D: ['y', -1], R: ['x', 1], L: ['x', -1], F: ['z', 1], B: ['z', -1] };
        const [axis, layer] = map[face];
        const turns = two ? 2 : 1;
        const clockwise = !prime;
        for (let t = 0; t < turns; t++) {
            handleMove(axis, layer, clockwise);
        }
        if (cubeInstance) cubeInstance.move(notation);
    }

    function screenMove(move) {
        if (isRotating || isChangingView || solveMode) return;
        const prime = move.endsWith('_prime');
        const base = move.replace('_prime', '');
        const faceMap = { R: 'R', L: 'L', U: 'U', D: 'D', F: 'F', B: 'B' };
        const notation = faceMap[base] + (prime ? "'" : '');
        performMove(notation);
    }

    function scramble() {
        if (solveMode) return;
        solveMode = true;
        moveQueue = [];
        if (cubeInstance) {
            const scrambleStr = cubeInstance.randomize();
            moveQueue = scrambleStr.split(' ');
        } else {
            // Fallback random moves
            for (let i = 0; i < 25; i++) {
                const faces = ['R', 'L', 'U', 'D', 'F', 'B'];
                const face = faces[Math.floor(Math.random() * faces.length)];
                const mods = ['', "'", '2'];
                moveQueue.push(face + mods[Math.floor(Math.random() * mods.length)]);
            }
        }
        setInfo('Scrambling...');
        executeNextMove();
    }

    function solveCube() {
        if (solveMode || !cubeInstance) return;
        solveMode = true;
        setInfo('Computing optimal solution...');
        const solution = cubeInstance.solve();
        moveQueue = solution.trim().split(' ');
        setInfo(`Solving in ${moveQueue.length} moves...`);
        setTimeout(() => executeNextMove(), 1000);
    }

    function setInfo(text) {
        const el = document.getElementById('info');
        el.textContent = text;
        el.style.opacity = 1;
        if (!text) setTimeout(() => el.style.opacity = 0, 2000);
    }

    function resetCube() {
        solveMode = false;
        moveQueue = [];
        if (cubeInstance) cubeInstance = new Cube();
        location.reload(); // Simple reset
    }

    function animate() {
        requestAnimationFrame(animate);
        if (!solveMode && !isRotating && !isChangingView) {
            cubeGroup.rotation.y += 0.005;
        }
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
