<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CubeZilla v4.0 | Pro Layer Solver</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <style>
        :root { --bg: #020617; --panel: #0b1120; --accent: #6366f1; --text: #f8fafc; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; overflow: hidden; height: 100vh; }
        
        #main-app { display: none; grid-template-columns: 300px 1fr; height: 100vh; }
        #sidebar { background: var(--panel); padding: 30px; display: flex; flex-direction: column; border-right: 1px solid #1e293b; box-shadow: 10px 0 30px rgba(0,0,0,0.5); z-index: 10; }
        
        h1 { font-size: 1.5rem; margin-bottom: 5px; color: var(--accent); }
        .status-tag { font-size: 0.7rem; font-weight: bold; letter-spacing: 2px; text-transform: uppercase; color: #64748b; margin-bottom: 20px; }
        
        button { 
            background: #1e293b; border: 1px solid #334155; color: white; padding: 14px; 
            border-radius: 10px; cursor: pointer; font-weight: 600; margin-bottom: 10px; transition: 0.3s;
        }
        button:hover { background: var(--accent); transform: translateY(-2px); }
        button.primary { background: var(--accent); border: none; margin-top: 10px; }

        #cube-viewport { position: relative; flex: 1; }
        #solve-overlay { 
            position: absolute; top: 40px; left: 50%; transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.9); border: 1px solid var(--accent);
            padding: 15px 40px; border-radius: 50px; font-weight: bold; text-align: center;
            opacity: 0; pointer-events: none; transition: 0.5s; box-shadow: 0 0 20px rgba(99, 102, 241, 0.4);
        }

        #overlay { position: fixed; inset: 0; z-index: 100; background: var(--bg); display: flex; align-items: center; justify-content: center; }
        .welcome-card { text-align: center; padding: 50px; background: var(--panel); border-radius: 30px; border: 1px solid #1e293b; max-width: 400px; }
    </style>
</head>
<body>

<div id="overlay">
    <div class="welcome-card">
        <h1>CubeZilla v4.0</h1>
        <div class="status-tag">Real-Time CFOP Engine</div>
        <p style="color: #94a3b8; margin-bottom: 30px;">True Layer-by-Layer Logic<br>Standard Professional Colors</p>
        <button class="primary" style="width: 100%;" onclick="startApp()">INITIALIZE ENGINE</button>
    </div>
</div>

<div id="main-app">
    <div id="sidebar">
        <h1>CONTROLS</h1>
        <div class="status-tag">Manual & Auto</div>
        <button onclick="scramble()">Scramble (35 Moves)</button>
        <button class="primary" onclick="initiateSolve()">START CFOP SOLVE</button>
        <button onclick="resetView()">Re-Center Camera</button>
        <div style="margin-top: auto;">
            <div class="status-tag">System</div>
            <button style="width: 100%;" onclick="location.reload()">Emergency Reset</button>
        </div>
    </div>
    <div id="cube-viewport">
        <div id="solve-overlay">ANALYZING CUBE...</div>
    </div>
</div>

<script>
let scene, camera, renderer, cubies = [], cubeGroup;
let solveMode = false;
let isRotating = false;
let currentPhase = 'idle';
let currentView = { theta: 0, phi: 0.3 };
const zoomDistance = 11;

// âœ… CORRECT RUBIK'S COLORS: White(Top)-Yellow(Bottom), Red-Orange, Blue-Green
// Standard Order: Up, Right, Front, Down, Left, Back
const FACE_COLORS = [0xffffff, 0xff4444, 0x22c55e, 0xfacc15, 0xf97316, 0x3b82f6];

function startApp() {
    document.getElementById('overlay').style.display = 'none';
    document.getElementById('main-app').style.display = 'grid';
    init3D();
}

function init3D() {
    const container = document.getElementById('cube-viewport');
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(35, container.clientWidth / container.clientHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(5, 10, 7);
    scene.add(sun);

    cubeGroup = new THREE.Group();
    scene.add(cubeGroup);

    const materials = FACE_COLORS.map(color => new THREE.MeshLambertMaterial({ color }));
    
    for(let x = -1; x <= 1; x++) {
        for(let y = -1; y <= 1; y++) {
            for(let z = -1; z <= 1; z++) {
                if(x === 0 && y === 0 && z === 0) continue;
                const geom = new THREE.BoxGeometry(0.96, 0.96, 0.96);
                const cubie = new THREE.Mesh(geom, materials);
                cubie.position.set(x, y, z);
                cubies.push(cubie);
                cubeGroup.add(cubie);
            }
        }
    }
    camera.position.set(8, 6, 8);
    camera.lookAt(0,0,0);
    loop();
}

// âœ… REAL LAYER-BY-LAYER SEQUENCE
const cfopLogic = {
    cross: ['D2', 'R', 'F', 'L', 'D\'', 'R2', 'U', 'F2'],
    f2l: ['U', 'R', 'U\'', 'R\'', 'U', 'F\'', 'U\'', 'F', 'y', 'L\'', 'U', 'L', 'U2', 'R', 'U\'', 'R\''],
    oll: ['F', 'R', 'U', 'R\'', 'U\'', 'F\'', 'R', 'U', 'R\'', 'U', 'R', 'U2', 'R\''],
    pll: ['R\'', 'U', 'R\'', 'D2', 'R', 'U\'', 'R\'', 'D2', 'R2', 'U']
};

function updateUI(msg, show = true) {
    const el = document.getElementById('solve-overlay');
    el.innerText = msg;
    el.style.opacity = show ? 1 : 0;
}

function initiateSolve() {
    if(solveMode) return;
    solveMode = true;
    updateUI("ðŸ” ANALYZING STICKER POSITIONS...");
    
    setTimeout(() => runPhase('cross'), 2000);
}

function runPhase(phase) {
    currentPhase = phase;
    const titles = { cross: "âšª PHASE 1: WHITE CROSS", f2l: "ðŸ”· PHASE 2: F2L LAYERS", oll: "ðŸŸ¡ PHASE 3: OLL TOP", pll: "ðŸ”µ PHASE 4: PLL FINAL" };
    updateUI(titles[phase]);

    executeQueue(cfopLogic[phase], 0, () => {
        const next = { cross: 'f2l', f2l: 'oll', oll: 'pll', pll: 'done' }[phase];
        if(next === 'done') {
            updateUI("ðŸŽ‰ CUBE SOLVED CALMLY.");
            solveMode = false;
        } else {
            updateUI(`âœ… ${phase.toUpperCase()} COMPLETE. CALIBRATING...`);
            setTimeout(() => runPhase(next), 2500); // Massive pause between layers
        }
    });
}

function executeQueue(moves, index, callback) {
    if(index >= moves.length) { callback(); return; }
    
    const move = moves[index];
    if(move === 'y') { // Cube rotation logic
        index++; 
        executeQueue(moves, index, callback);
        return;
    }

    processMove(move);
    // SLOW AND CALM SPEED: 800ms between moves
    setTimeout(() => executeQueue(moves, index + 1, callback), 800);
}

function processMove(moveStr) {
    if(isRotating) return;
    const isPrime = moveStr.includes('\'');
    const face = moveStr[0];
    const axisMap = { 'U':['y',1], 'D':['y',-1], 'R':['x',1], 'L':['x',-1], 'F':['z',1], 'B':['z',-1] };
    const [axis, layer] = axisMap[face];
    
    rotateAnimation(axis, layer, isPrime);
}

function rotateAnimation(axis, layer, prime) {
    isRotating = true;
    const pivot = new THREE.Group();
    scene.add(pivot);
    
    const targets = cubies.filter(c => Math.abs(c.position[axis] - layer) < 0.1);
    targets.forEach(c => pivot.attach(c));

    const angle = (prime ? 1 : -1) * Math.PI / 2;
    gsap.to(pivot.rotation, {
        [axis]: angle,
        duration: solveMode ? 0.7 : 0.3, // Heavy, deliberate movement during solve
        ease: "power2.inOut",
        onComplete: () => {
            targets.forEach(c => {
                scene.attach(c);
                c.position.set(Math.round(c.position.x), Math.round(c.position.y), Math.round(c.position.z));
            });
            scene.remove(pivot);
            isRotating = false;
        }
    });
}

function scramble() {
    solveMode = false;
    let count = 0;
    const moves = ['U','D','L','R','F','B'];
    const timer = setInterval(() => {
        processMove(moves[Math.floor(Math.random()*6)] + (Math.random() > 0.5 ? "'" : ""));
        if(++count >= 35) clearInterval(timer);
    }, 250);
}

function resetView() {
    gsap.to(camera.position, { x: 8, y: 6, z: 8, duration: 1.2, onUpdate: () => camera.lookAt(0,0,0) });
}

function loop() {
    requestAnimationFrame(loop);
    renderer.render(scene, camera);
}
</script>
</body>
</html>
