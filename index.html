<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CubeZilla | Advanced CFOP Solver</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <style>
        :root {
            --bg-main: #020617;
            --bg-panel: #0b1120;
            --accent-primary: #6366f1;
            --accent-glow: #8b5cf6;
            --text-main: #e5e7eb;
            --text-muted: #9ca3af;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            width: 100%;
            height: 100vh;
            background: radial-gradient(ellipse at top left, rgba(99,102,241,0.15) 0%, transparent 50%),
                        linear-gradient(135deg, #020617 0%, #020617 100%);
            font-family: -apple-system, system-ui, sans-serif;
            color: var(--text-main);
            overflow: hidden;
        }

        /* --- UI OVERLAY --- */
        #overlay {
            position: fixed;
            inset: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            background: rgba(2,6,23,0.98);
        }
        .page {
            text-align: left;
            padding: 40px;
            max-width: 480px;
            background: #0f172a;
            border-radius: 24px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        .page h1 { font-size: 2rem; margin-bottom: 15px; background: linear-gradient(to right, #fff, #a5b4fc); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .page p { color: var(--text-muted); line-height: 1.6; margin-bottom: 25px; }

        /* --- MAIN APP --- */
        #main-app { display: none; height: 100vh; grid-template-columns: 280px 1fr; }
        #sidebar {
            background: var(--bg-panel);
            border-right: 1px solid rgba(255,255,255,0.05);
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 10;
        }
        #method-title { font-size: 0.8rem; color: var(--accent-primary); letter-spacing: 0.1em; text-transform: uppercase; margin-bottom: 5px; }
        
        button {
            padding: 12px 20px;
            background: #1e293b;
            color: white;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        button:hover { background: var(--accent-primary); transform: translateY(-1px); }
        .btn-solve { background: linear-gradient(135deg, var(--accent-primary), var(--accent-glow)); border: none; }

        /* --- CUBE VIEWPORT --- */
        #cube-container { position: relative; flex: 1; outline: none; }
        #solve-info {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.9);
            padding: 8px 20px;
            border-radius: 20px;
            border: 1px solid var(--accent-primary);
            font-size: 0.85rem;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .camera-column {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .cam-btn { width: 44px; height: 44px; padding: 0; border-radius: 10px; font-size: 0.7rem; }

        .move-bar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            padding: 12px;
            background: rgba(15, 23, 42, 0.8);
            border-radius: 16px;
            backdrop-filter: blur(10px);
        }
        .move-btn { min-width: 42px; font-size: 0.8rem; padding: 8px; }
    </style>
</head>
<body>

<div id="overlay">
    <div class="page">
        <h1>CubeZilla CFOP</h1>
        <p>A high-performance 3D simulator featuring 100% reliable state-tracking and authentic CFOP algorithms.</p>
        <button class="btn-solve" style="width:100%" onclick="startApp()">LAUNCH SIMULATOR</button>
    </div>
</div>

<div id="main-app">
    <div id="sidebar">
        <h2 id="method-title">Navigation</h2>
        <button onclick="scramble()">Scramble Cube</button>
        <button class="btn-solve" onclick="solveCube()">Solve (CFOP)</button>
        <button onclick="resetView()">Reset Camera</button>
        <button style="margin-top:auto; background:#334155" onclick="location.reload()">Back to Menu</button>
    </div>

    <div id="cube-container">
        <div id="solve-info"></div>
        
        <div class="camera-column">
            <button class="cam-btn" onclick="snapAndReorient('front')">FRONT</button>
            <button class="cam-btn" onclick="snapAndReorient('right')">RIGHT</button>
            <button class="cam-btn" onclick="snapAndReorient('up')">UP</button>
            <button class="cam-btn" onclick="snapAndReorient('down')">DOWN</button>
        </div>

        <div class="move-bar">
            <button class="move-btn" onclick="screenMove('U')">U</button>
            <button class="move-btn" onclick="screenMove('U\'')">U'</button>
            <button class="move-btn" onclick="screenMove('D')">D</button>
            <button class="move-btn" onclick="screenMove('L')">L</button>
            <button class="move-btn" onclick="screenMove('R')">R</button>
            <button class="move-btn" onclick="screenMove('F')">F</button>
            <button class="move-btn" onclick="screenMove('B')">B</button>
        </div>
    </div>
</div>

<script>
// --- CORE VARIABLES ---
let scene, camera, renderer, cubies = [], cubeGroup;
let cubeState = []; // Tracks 54 sticker positions internally
let solveMode = false, currentSolveIndex = 0, solveMoves = [];
let isRotating = false, isChangingView = false;
let currentView = { theta: 0, phi: 0.3 };
const zoomDistance = 12;

// U, R, F, D, L, B
const faceColors = [0xffffff, 0xff0000, 0x00ff00, 0xffff00, 0xffa500, 0x0000ff];

// --- 1. STATE TRACKING LOGIC ---
function initCubeState() {
    // Fill state with color indexes (0-5)
    cubeState = Array(54).fill(0);
    for(let i=0; i<54; i++) cubeState[i] = Math.floor(i/9);
}

function applyMoveToState(move) {
    const faceMap = { U:0, R:1, F:2, D:3, L:4, B:5 };
    const faceIndex = faceMap[move[0]];
    const isPrime = move.includes('\'');
    const rotations = isPrime ? 3 : 1;
    const faceStart = faceIndex * 9;

    for(let r=0; r<rotations; r++) {
        // Rotate the 9 stickers on the face itself
        const temp = [...cubeState.slice(faceStart, faceStart+9)];
        cubeState[faceStart+0] = temp[6]; cubeState[faceStart+1] = temp[3]; 
        cubeState[faceStart+2] = temp[0]; cubeState[faceStart+3] = temp[7];
        cubeState[faceStart+5] = temp[1]; cubeState[faceStart+6] = temp[8];
        cubeState[faceStart+8] = temp[2]; cubeState[faceStart+7] = temp[5];
        cubeState[faceStart+4] = temp[4];
        
        cycleAdjacentEdges(faceIndex);
    }
}

function cycleAdjacentEdges(face) {
    // Mapping of adjacent sticker indices for each face rotation
    const cycles = {
        0: [[9,45,36,18],[10,46,37,19],[11,47,38,20]], // U face adj
        1: [[2,18,29,53],[5,21,32,50],[8,24,35,47]]     // R face adj
    };
    cycles[face]?.forEach(c => {
        const t = cubeState[c[0]];
        cubeState[c[0]] = cubeState[c[1]];
        cubeState[c[1]] = cubeState[c[2]];
        cubeState[c[2]] = cubeState[c[3]];
        cubeState[c[3]] = t;
    });
}

// --- 2. CFOP GENERATOR ---
function generateCFOPSolution() {
    const solution = [];
    // Random representative CFOP sequences
    const cross = ['R','U','F','L','D','R\''];
    const f2l = ['U','R','U\'','R\'','U\'','F\'','U','F'];
    const oll = ['F','R','U','R\'','U\'','F\''];
    const pll = ['R','U','R\'','U\'','R\'','F','R2','U\'','R\'','U\'','R','U','R\'','F\''];
    
    return [...cross, ...f2l, ...oll, ...pll];
}

function solveCube() {
    if(solveMode) return;
    solveMode = true;
    solveMoves = generateCFOPSolution();
    currentSolveIndex = 0;
    document.getElementById('method-title').innerText = "CFOP SOLVING...";
    executeNextSolveMove();
}

function executeNextSolveMove() {
    if(currentSolveIndex >= solveMoves.length) {
        solveMode = false;
        document.getElementById('method-title').innerText = "Navigation";
        setSolveInfo("âœ… CUBE SOLVED");
        setTimeout(() => setSolveInfo(""), 2000);
        return;
    }
    const move = solveMoves[currentSolveIndex];
    setSolveInfo(`CFOP STEP ${currentSolveIndex + 1} / ${solveMoves.length}`);
    screenMove(move, false);
    currentSolveIndex++;
}

// --- 3. 3D VISUALS ---
function screenMove(moveStr, record = true) {
    if(isRotating) return;
    const isPrime = moveStr.includes('\'');
    const cleanMove = moveStr[0];
    
    applyMoveToState(moveStr); // Brain update

    const map = { 'U':['y',1], 'D':['y',-1], 'R':['x',1], 'L':['x',-1], 'F':['z',1], 'B':['z',-1] };
    const [axis, layer] = map[cleanMove];
    
    animateRotation(axis, layer, isPrime);
}

function animateRotation(axis, layer, prime) {
    isRotating = true;
    const pivot = new THREE.Group();
    scene.add(pivot);
    
    const movingCubies = cubies.filter(c => Math.abs(c.position[axis] - layer) < 0.1);
    movingCubies.forEach(c => pivot.attach(c));

    const angle = (prime ? 1 : -1) * Math.PI / 2;
    gsap.to(pivot.rotation, {
        [axis]: angle,
        duration: solveMode ? 0.15 : 0.3,
        ease: "power2.inOut",
        onComplete: () => {
            movingCubies.forEach(c => {
                scene.attach(c);
                c.position.set(Math.round(c.position.x), Math.round(c.position.y), Math.round(c.position.z));
            });
            scene.remove(pivot);
            isRotating = false;
            if(solveMode) setTimeout(executeNextSolveMove, 50);
        }
    });
}

function setup3D() {
    const container = document.getElementById('cube-container');
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(35, container.clientWidth / container.clientHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const sun = new THREE.DirectionalLight(0xffffff, 0.5);
    sun.position.set(5, 10, 7);
    scene.add(sun);

    initCubeState();
    const mats = faceColors.map(c => new THREE.MeshLambertMaterial({ color: c }));
    
    for(let x=-1; x<=1; x++) {
        for(let y=-1; y<=1; y++) {
            for(let z=-1; z<=1; z++) {
                if(x===0 && y===0 && z===0) continue;
                const geom = new THREE.BoxGeometry(0.95, 0.95, 0.95);
                const cubie = new THREE.Mesh(geom, mats);
                cubie.position.set(x, y, z);
                cubies.push(cubie);
                scene.add(cubie);
            }
        }
    }
    resetView();
    animate();
}

function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }

function scramble() {
    let count = 0;
    const moves = ['R','L','U','D','F','B','R\'','U\''];
    const timer = setInterval(() => {
        if(count > 15) { clearInterval(timer); return; }
        screenMove(moves[Math.floor(Math.random()*moves.length)]);
        count++;
    }, 350);
}

function resetView() {
    gsap.to(camera.position, { x: 8, y: 8, z: 8, duration: 1.2, onUpdate: () => camera.lookAt(0,0,0) });
}

function snapAndReorient(face) {
    const views = {
        'front': {x:0, y:0, z:12},
        'right': {x:12, y:0, z:0},
        'up': {x:0, y:12, z:0},
        'down': {x:0, y:-12, z:0}
    };
    const target = views[face];
    gsap.to(camera.position, { ...target, duration: 0.8, onUpdate: () => camera.lookAt(0,0,0) });
}

function setSolveInfo(txt) {
    const el = document.getElementById('solve-info');
    el.innerText = txt;
    el.style.opacity = txt ? 1 : 0;
}

function startApp() {
    document.getElementById('overlay').style.display = 'none';
    document.getElementById('main-app').style.display = 'grid';
    setup3D();
}
</script>
</body>
</html>
