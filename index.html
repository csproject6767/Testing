<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CubeZilla v5.0 | Complete & Correct</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cubejs@0.4.1/cube.min.js"></script>
    <style>
        :root {
            --bg-main: #020617;
            --accent-primary: #6366f1;
            --text-main: #e5e7eb;
            --text-muted: #9ca3af;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: var(--bg-main); color: var(--text-main); font-family: sans-serif; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
        #overlay { position: fixed; inset: 0; background: rgba(2,6,23,0.96); display: flex; align-items: center; justify-content: center; z-index: 100; }
        .page { background: #0f172a; padding: 40px; border-radius: 26px; text-align: center; box-shadow: 0 0 40px rgba(99,102,241,0.4); max-width: 480px; }
        .pop-btn { padding: 14px 28px; background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; border: none; border-radius: 999px; cursor: pointer; font-weight: 600; margin: 5px; }
        #controls { padding: 20px; background: #0b1120; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
        #container { flex: 1; position: relative; }
        #info { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(15,23,42,0.9); padding: 10px 20px; border-radius: 999px; border: 1px solid #6366f1; opacity: 0; transition: opacity 0.3s; z-index: 10; color: var(--text-muted); font-size: 0.9rem; }
        .camera-column { position: absolute; left: 20px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 10px; z-index: 10; }
        .camera-btn { background: #1e293b; color: white; border: 1px solid #334155; padding: 10px; border-radius: 10px; cursor: pointer; width: 50px; font-weight: bold; }
        .move-bar { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; background: rgba(15,23,42,0.9); padding: 12px; border-radius: 20px; border: 1px solid #6366f1; z-index: 10; }
        .move-btn { background: #1e293b; color: white; border: 1px solid #334155; padding: 8px 14px; border-radius: 8px; cursor: pointer; font-size: 0.9rem; font-weight: bold; }
    </style>
</head>
<body>

<div id="overlay">
    <div class="page">
        <h1>CubeZilla v5.0</h1>
        <p>Complete optimal solver with correct turn directions.</p>
        <button class="pop-btn" onclick="startApp()">Start</button>
    </div>
</div>

<div id="container"></div>
<div id="controls">
    <button class="pop-btn" onclick="scramble()">Scramble</button>
    <button class="pop-btn" onclick="solveCube()">Solve Optimal</button>
    <button class="pop-btn" onclick="resetCube()">Reset</button>
</div>
<div id="info"></div>

<div class="camera-column">
    <button class="camera-btn" onclick="snapAndReorient('front')">F</button>
    <button class="camera-btn" onclick="snapAndReorient('right')">R</button>
    <button class="camera-btn" onclick="snapAndReorient('back')">B</button>
    <button class="camera-btn" onclick="snapAndReorient('left')">L</button>
    <button class="camera-btn" onclick="snapAndReorient('up')">U</button>
    <button class="camera-btn" onclick="snapAndReorient('down')">D</button>
</div>
<div class="move-bar">
    <button class="move-btn" onclick="screenMove('R')">R</button>
    <button class="move-btn" onclick="screenMove('R_prime')">R'</button>
    <button class="move-btn" onclick="screenMove('L')">L</button>
    <button class="move-btn" onclick="screenMove('L_prime')">L'</button>
    <button class="move-btn" onclick="screenMove('U')">U</button>
    <button class="move-btn" onclick="screenMove('U_prime')">U'</button>
    <button class="move-btn" onclick="screenMove('F')">F</button>
    <button class="move-btn" onclick="screenMove('F_prime')">F'</button>
</div>

<script>
    let scene, camera, renderer, cubeGroup, cubies = [];
    let isRotating = false, isChangingView = false, solveMode = false;
    let currentView = { theta: 0.8, phi: 0.4 };
    const zoomDistance = 12;
    let moveQueue = [];
    let cubeInstance;

    const FACE_COLORS = [0xffffff, 0xff4444, 0x22c55e, 0xfacc15, 0xf97316, 0x3b82f6]; // U R F D L B

    function startApp() {
        document.getElementById('overlay').style.display = 'none';
        cubeInstance = typeof Cube !== 'undefined' ? new Cube() : null;
        if (cubeInstance) {
            Cube.initSolver();
            setInfo('Optimal solver ready');
        } else {
            setInfo('Solver not loaded (basic mode)');
        }
        setup3D();
    }

    function setup3D() {
        const container = document.getElementById('container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020617);

        camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        scene.add(new THREE.DirectionalLight(0xffffff, 1).position.set(5, 10, 7));

        cubeGroup = new THREE.Group();
        scene.add(cubeGroup);

        const materials = FACE_COLORS.map(c => new THREE.MeshLambertMaterial({ color: c }));

        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    if (x === 0 && y === 0 && z === 0) continue;
                    const cubie = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.95, 0.95), materials);
                    cubie.position.set(x, y, z);
                    cubies.push(cubie);
                    cubeGroup.add(cubie);
                }
            }
        }

        updateCamera();
        window.addEventListener('resize', onWindowResize);
        animate();
    }

    function onWindowResize() {
        const container = document.getElementById('container');
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }

    function updateCamera() {
        camera.position.set(
            zoomDistance * Math.cos(currentView.phi) * Math.sin(currentView.theta),
            zoomDistance * Math.sin(currentView.phi),
            zoomDistance * Math.cos(currentView.phi) * Math.cos(currentView.theta)
        );
        camera.lookAt(0, 0, 0);
    }

    function snapAndReorient(target) {
        if (isChangingView || isRotating) return;
        isChangingView = true;
        const views = {
            front: { theta: 0, phi: 0.3 },
            right: { theta: -Math.PI/2, phi: 0.3 },
            back: { theta: Math.PI, phi: 0.3 },
            left: { theta: Math.PI/2, phi: 0.3 },
            up: { theta: 0, phi: -Math.PI/2 + 0.2 },
            down: { theta: 0, phi: Math.PI/2 - 0.2 }
        };
        const v = views[target] || views.front;
        gsap.to(currentView, {
            theta: v.theta, phi: v.phi, duration: 1, ease: "power2.inOut",
            onUpdate: updateCamera,
            onComplete: () => isChangingView = false
        });
    }

    function handleMove(axis, layer, clockwise = true) {
        if (isRotating) return;
        isRotating = true;
        const pivot = new THREE.Group();
        cubeGroup.add(pivot);

        const moving = cubies.filter(c => Math.abs(c.position[axis] - layer) < 0.1);
        moving.forEach(c => pivot.attach(c));

        const angle = clockwise ? Math.PI / 2 : -Math.PI / 2;
        const duration = solveMode ? 0.7 : 0.4;

        gsap.to(pivot.rotation, {
            [axis]: pivot.rotation[axis] + angle,
            duration,
            ease: "power2.inOut",
            onComplete: () => {
                moving.forEach(c => {
                    cubeGroup.attach(c);
                    c.position.copy(c.position.applyAxisAngle(new THREE.Vector3().setFromMatrixColumn(pivot.matrix, 0), angle).set(
                        Math.round(c.position.x), Math.round(c.position.y), Math.round(c.position.z)
                    ));
                });
                cubeGroup.remove(pivot);
                isRotating = false;
                if (solveMode && moveQueue.length > 0) setTimeout(executeNextMove, 200);
            }
        });
    }

    function executeNextMove() {
        if (moveQueue.length === 0 || isRotating) return;
        const move = moveQueue.shift();
        performMove(move);
    }

    function performMove(notation) {
        const prime = notation.includes("'");
        const two = notation.includes("2");
        const face = notation[0];
        const map = { U: ['y', 1], D: ['y', -1], R: ['x', 1], L: ['x', -1], F: ['z', 1], B: ['z', -1] };
        const [axis, layer] = map[face];
        const turns = two ? 2 : 1;
        const dir = !prime;
        for (let i = 0; i < turns; i++) {
            handleMove(axis, layer, dir);
        }
        if (cubeInstance) cubeInstance.move(notation);
    }

    function screenMove(move) {
        if (isRotating || isChangingView || solveMode) return;
        const prime = move.endsWith('_prime');
        const base = move.replace('_prime', '');

        camera.updateMatrixWorld();
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward).negate();
        const right = new THREE.Vector3().setFromMatrixColumn(camera.matrixWorld, 0);
        const up = new THREE.Vector3().setFromMatrixColumn(camera.matrixWorld, 1);

        const directions = {
            R: right, L: right.clone().negate(),
            U: up, D: up.clone().negate(),
            F: forward, B: forward.clone().negate()
        };
        const dir = directions[base];

        const dots = {
            x: Math.abs(dir.dot(new THREE.Vector3(1,0,0))),
            y: Math.abs(dir.dot(new THREE.Vector3(0,1,0))),
            z: Math.abs(dir.dot(new THREE.Vector3(0,0,1)))
        };
        let axis = 'x';
        if (dots.y > dots.x && dots.y > dots.z) axis = 'y';
        if (dots.z > dots.x && dots.z > dots.y) axis = 'z';

        const layerSign = dir.dot(axis === 'x' ? new THREE.Vector3(1,0,0) : axis === 'y' ? new THREE.Vector3(0,1,0) : new THREE.Vector3(0,0,1)) > 0 ? 1 : -1;
        const faceMap = { x: { 1: 'R', '-1': 'L' }, y: { 1: 'U', '-1': 'D' }, z: { 1: 'F', '-1': 'B' } };
        const detectedFace = faceMap[axis][layerSign];
        const notation = detectedFace + (prime ? "'" : '');

        performMove(notation);
    }

    function scramble() {
        if (solveMode) return;
        solveMode = true;
        moveQueue = [];
        if (cubeInstance) {
            cubeInstance = new Cube();
            const scr = cubeInstance.randomize();
            moveQueue = scr.split(' ');
        } else {
            const faces = ['R','L','U','D','F','B'];
            for (let i = 0; i < 25; i++) {
                const f = faces[Math.floor(Math.random()*6)];
                const mod = Math.random() < 0.3 ? '2' : Math.random() < 0.5 ? "'" : '';
                moveQueue.push(f + mod);
            }
        }
        setInfo('Scrambling...');
        executeNextMove();
        setTimeout(() => { solveMode = false; setInfo(''); }, moveQueue.length * 600);
    }

    function solveCube() {
        if (solveMode || !cubeInstance) return;
        solveMode = true;
        setInfo('Computing optimal solution...');
        const solution = cubeInstance.solve();
        moveQueue = solution.trim().split(' ');
        setInfo(`Solving in ${moveQueue.length} moves...`);
        executeNextMove();
        setTimeout(() => {
            setInfo('Solved! ðŸŽ‰');
            setTimeout(() => { setInfo(''); solveMode = false; }, 3000);
        }, moveQueue.length * 700 + 1000);
    }

    function setInfo(text) {
        const el = document.getElementById('info');
        el.textContent = text || '';
        el.style.opacity = text ? 1 : 0;
    }

    function resetCube() {
        location.reload();
    }

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
