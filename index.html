<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CubeZilla v5.0 | Optimal Layer Solver</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <!-- Cube.js solver (Kociemba two-phase algorithm) -->
    <script src="https://cdn.jsdelivr.net/npm/cubejs@0.4.1/lib/cube.js"></script>
    <style>
        :root {
            --bg-main: #020617;
            --bg-panel: #0b1120;
            --bg-glass: rgba(15, 23, 42, 0.92);
            --accent-primary: #6366f1;
            --accent-glow: #8b5cf6;
            --accent-soft: #a5b4fc;
            --text-main: #e5e7eb;
            --text-muted: #9ca3af;
            --border-glow: rgba(99, 102, 241, 0.4);
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            width: 100%; height: 100vh; background:
                radial-gradient(ellipse at top left, rgba(99,102,241,0.18) 0%, transparent 55%),
                radial-gradient(ellipse at bottom right, rgba(139,92,246,0.16) 0%, transparent 55%),
                linear-gradient(135deg, #020617 0%, #020617 100%);
            font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
            color: var(--text-main); overflow: hidden;
        }
        #overlay {
            position: fixed; inset: 0; display: flex; justify-content: center; align-items: center; z-index: 100;
            background: rgba(2,6,23,0.96);
        }
        .page {
            text-align: left; padding: 40px 44px 32px; max-width: 480px; width: 90vw;
            background: linear-gradient(145deg, rgba(15,23,42,0.96) 0%, rgba(15,23,42,0.92) 100%);
            border-radius: 26px; border: 1px solid rgba(148,163,184,0.4);
            box-shadow: 0 30px 80px rgba(15,23,42,0.9), 0 0 40px rgba(79,70,229,0.4); position: relative; overflow: hidden;
        }
        .page::before {
            content: ''; position: absolute; inset: -1px; border-radius: 26px;
            background: radial-gradient(circle at 0% 0%, rgba(129,140,248,0.4) 0%, transparent 45%),
                        radial-gradient(circle at 100% 100%, rgba(236,72,153,0.3) 0%, transparent 45%);
            opacity: 0.45; mix-blend-mode: screen; pointer-events: none;
        }
        .page h1 { font-size: 2.1rem; margin-bottom: 12px; letter-spacing: -0.03em;
            background: linear-gradient(135deg, #e5e7eb, #a5b4fc); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .page p { margin-bottom: 18px; color: var(--text-muted); line-height: 1.6; font-size: 0.95rem; }
        .pop-btn {
            padding: 12px 26px; background: linear-gradient(135deg, var(--accent-primary), var(--accent-glow));
            color: white; border: none; border-radius: 999px; cursor: pointer; font-weight: 600;
            font-size: 0.95rem; letter-spacing: 0.05em; text-transform: uppercase; position: relative;
            overflow: hidden; transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 18px 40px rgba(59,130,246,0.45), 0 0 0 1px rgba(129,140,248,0.6);
        }
        .pop-btn:hover { transform: translateY(-2px) scale(1.02);
            box-shadow: 0 24px 55px rgba(79,70,229,0.6), 0 0 0 1px rgba(191,219,254,0.9);
        }
        #main-app { display: none; height: 100vh; display: grid; grid-template-columns: 300px 1fr; }
        #sidebar {
            background: linear-gradient(180deg, #020617 0%, #020617 100%);
            border-right: 1px solid rgba(15,23,42,1); padding: 22px 20px;
            display: flex; flex-direction: column; gap: 16px; box-shadow: 10px 0 40px rgba(0,0,0,0.6);
        }
        #method-title {
            font-size: 0.9rem; color: var(--accent-soft); letter-spacing: 0.16em;
            text-transform: uppercase; margin-bottom: 8px;
        }
        #cube-container { position: relative; flex: 1; }
        #solve-info {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            padding: 8px 18px; background: rgba(15,23,42,0.95); border-radius: 999px;
            border: 1px solid rgba(148,163,184,0.6); color: var(--text-muted);
            font-size: 0.8rem; letter-spacing: 0.08em; text-transform: uppercase;
            opacity: 0; transition: opacity 0.3s ease; z-index: 10;
        }
        .camera-column {
            position: absolute; top: 50%; left: 24px; transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 12px;
        }
        .camera-btn {
            width: 46px; height: 46px; background: radial-gradient(circle at 30% 0%, #111827, #020617);
            color: #e5e7eb; border-radius: 14px; border: 1px solid rgba(75,85,99,0.9);
            cursor: pointer; font-weight: 600; display: flex; align-items: center; justify-content: center;
        }
        .move-bar {
            position: absolute; bottom: 34px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; padding: 14px 16px; background: rgba(15,23,42,0.98);
            border-radius: 18px; border: 1px solid rgba(51,65,85,0.9);
        }
        .move-btn {
            padding: 8px 10px; min-width: 40px; background: #0f172a; color: #e5e7eb;
            border-radius: 10px; border: 1px solid rgba(55,65,81,0.9); cursor: pointer;
            font-size: 0.8rem; text-transform: uppercase;
        }
    </style>
</head>
<body>

<div id="overlay">
    <div class="page">
        <h1>CubeZilla v5.0</h1>
        <p>Optimal Godâ€™s Number solver powered by Kociembaâ€™s algorithm.</p>
        <p>Scramble â†’ Solve â†’ Watch a perfect â‰¤22-move solution with cinematic animation.</p>
        <div style="display:flex; flex-direction:column; gap:12px; margin-bottom:26px;">
            <button class="pop-btn" style="background:linear-gradient(135deg,#22c55e,#16a34a); box-shadow:0 18px 40px rgba(34,197,94,0.4);"
                    onclick="startApp()">Start Optimal Solver</button>
        </div>
        <div style="margin-top:10px; padding-top:10px; border-top:1px solid rgba(55,65,81,0.7); display:flex; justify-content:space-between; align-items:center; font-size:0.8rem; color:#9ca3af;">
            <span>Credits: Anirudh Â· Madhav Â· Pratik + Grok</span>
            <span>v5.0 Â· Optimal</span>
        </div>
    </div>
</div>

<div id="main-app">
    <div id="sidebar">
        <h2 id="method-title">CONTROLS</h2>
        <button class="pop-btn" onclick="scramble()">Scramble</button>
        <button class="pop-btn" onclick="solveCube()">Solve (Optimal)</button>
        <button class="pop-btn" onclick="resetCube()">Reset Cube</button>
        <button class="pop-btn" onclick="snapAndReorient('front')">Reset View</button>
        <button class="pop-btn" style="background:#374151" onclick="location.reload()">Back to Menu</button>
    </div>
    <div id="cube-container">
        <div id="solve-info">Initializing solver...</div>
        <div class="camera-column">
            <button class="camera-btn" onclick="snapAndReorient('front')">F</button>
            <button class="camera-btn" onclick="snapAndReorient('right')">R</button>
            <button class="camera-btn" onclick="snapAndReorient('back')">B</button>
            <button class="camera-btn" onclick="snapAndReorient('left')">L</button>
            <button class="camera-btn" onclick="snapAndReorient('up')">U</button>
            <button class="camera-btn" onclick="snapAndReorient('down')">D</button>
        </div>
        <div class="move-bar">
            <button class="move-btn" onclick="screenMove('R')">R</button>
            <button class="move-btn" onclick="screenMove('R_prime')">R'</button>
            <button class="move-btn" onclick="screenMove('L')">L</button>
            <button class="move-btn" onclick="screenMove('L_prime')">L'</button>
            <button class="move-btn" onclick="screenMove('U')">U</button>
            <button class="move-btn" onclick="screenMove('U_prime')">U'</button>
            <button class="move-btn" onclick="screenMove('F')">F</button>
            <button class="move-btn" onclick="screenMove('F_prime')">F'</button>
        </div>
    </div>
</div>

<script>
    let scene, camera, renderer, cubeGroup, cubies = [];
    let isRotating = false, isChangingView = false;
    let currentView = { theta: 0, phi: 0.3 };
    const zoomDistance = 12;
    let solveMode = false;
    let moveQueue = [];
    let cube = new Cube(); // cubejs instance

    // Standard colors: U=white, R=red, F=green, D=yellow, L=orange, B=blue
    const FACE_COLORS = [0xffffff, 0xff4444, 0x22c55e, 0xfacc15, 0xf97316, 0x3b82f6];

    function startApp() {
        document.getElementById('overlay').style.display = 'none';
        document.getElementById('main-app').style.display = 'grid';
        setSolveInfo('Initializing optimal solver...');
        Cube.initSolver(); // Takes ~4 seconds first time
        setTimeout(() => {
            setSolveInfo('');
            setup3D();
        }, 500);
    }

    function setup3D() {
        const container = document.getElementById('cube-container');
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(35, container.clientWidth / container.clientHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const dl = new THREE.DirectionalLight(0xffffff, 0.8);
        dl.position.set(3, 5, 4);
        scene.add(dl);

        cubeGroup = new THREE.Group();
        scene.add(cubeGroup);

        const materials = FACE_COLORS.map(c => new THREE.MeshLambertMaterial({ color: c }));

        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    if (x === 0 && y === 0 && z === 0) continue;
                    const cubie = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.95, 0.95), materials);
                    cubie.position.set(x, y, z);
                    cubies.push(cubie);
                    cubeGroup.add(cubie);
                }
            }
        }

        updateCamera();
        animate();
    }

    function updateCamera() {
        camera.position.set(
            zoomDistance * Math.cos(currentView.phi) * Math.sin(currentView.theta),
            zoomDistance * Math.sin(currentView.phi),
            zoomDistance * Math.cos(currentView.phi) * Math.cos(currentView.theta)
        );
        camera.lookAt(0, 0, 0);
    }

    function snapAndReorient(target) {
        if (isRotating || isChangingView) return;
        const views = {
            front: { t: 0, p: 0.3 }, right: { t: -Math.PI/2, p: 0.3 }, back: { t: Math.PI, p: 0.3 },
            left: { t: Math.PI/2, p: 0.3 }, up: { t: 0, p: -Math.PI/2 + 0.2 }, down: { t: 0, p: Math.PI/2 - 0.2 }
        };
        const v = views[target];
        isChangingView = true;
        gsap.to(currentView, {
            theta: v.t, phi: v.p, duration: 0.8, ease: "power2.inOut",
            onUpdate: updateCamera,
            onComplete: () => isChangingView = false
        });
    }

    function handleMove(axis, layer, clockwise = true) {
        if (isRotating) return;
        isRotating = true;
        const pivot = new THREE.Group();
        cubeGroup.add(pivot);

        const moving = cubies.filter(c => Math.abs(c.position[axis] - layer) < 0.1);
        moving.forEach(c => pivot.attach(c));

        const angle = clockwise ? Math.PI / 2 : -Math.PI / 2;
        const duration = solveMode ? 0.6 : 0.3;

        gsap.to(pivot.rotation, {
            [axis]: pivot.rotation[axis] + angle,
            duration,
            ease: "power2.inOut",
            onComplete: () => {
                moving.forEach(c => {
                    cubeGroup.attach(c);
                    c.position.set(Math.round(c.position.x), Math.round(c.position.y), Math.round(c.position.z));
                });
                cubeGroup.remove(pivot);
                isRotating = false;
                if (solveMode && moveQueue.length > 0) {
                    setTimeout(executeNextMove, 300);
                }
            }
        });
    }

    function executeNextMove() {
        if (moveQueue.length === 0 || isRotating) return;
        const move = moveQueue.shift();
        performMove(move);
    }

    function performMove(moveNotation) {
        // Convert notation like "R" or "R'" to face, axis, direction
        const prime = moveNotation.includes("'");
        const two = moveNotation.includes("2");
        const face = moveNotation[0];
        const map = { U: ["y", 1], D: ["y", -1], R: ["x", 1], L: ["x", -1], F: ["z", 1], B: ["z", -1] };
        const [axis, layer] = map[face];
        const turns = two ? 2 : 1;
        for (let i = 0; i < turns; i++) {
            handleMove(axis, layer, !prime);
        }
        // Apply to cubejs state
        cube.move(moveNotation);
    }

    function screenMove(move) {
        if (isRotating || isChangingView || solveMode) return;
        const prime = move.endsWith('_prime');
        const base = move.replace('_prime', '');
        const faceMap = { R: 'R', L: 'L', U: 'U', D: 'D', F: 'F', B: 'B' };
        const notation = base + (prime ? "'" : '');

        camera.updateMatrixWorld();
        const camForward = new THREE.Vector3();
        camera.getWorldDirection(camForward);
        const camRight = new THREE.Vector3().setFromMatrixColumn(camera.matrixWorld, 0);
        const camUp = new THREE.Vector3().setFromMatrixColumn(camera.matrixWorld, 1);

        const dirs = {
            R: camRight, L: camRight.clone().negate(),
            U: camUp, D: camUp.clone().negate(),
            F: camForward.clone().negate(), B: camForward
        };
        const dir = dirs[base];
        const dot = { x: Math.abs(dir.dot(new THREE.Vector3(1,0,0))), y: Math.abs(dir.dot(new THREE.Vector3(0,1,0))), z: Math.abs(dir.dot(new THREE.Vector3(0,0,1))) };
        let maxDot = Math.max(dot.x, dot.y, dot.z);
        let axis = dot.x === maxDot ? 'x' : (dot.y === maxDot ? 'y' : 'z');
        let layer = dir.dot(axis === 'x' ? new THREE.Vector3(1,0,0) : (axis === 'y' ? new THREE.Vector3(0,1,0) : new THREE.Vector3(0,0,1))) > 0 ? 1 : -1;
        const faceFromAxis = { 'x1': 'R', 'x-1': 'L', 'y1': 'U', 'y-1': 'D', 'z1': 'F', 'z-1': 'B' };
        const detectedFace = faceFromAxis[axis + layer];
        const detectedNotation = detectedFace + (prime ? "'" : '');

        performMove(detectedNotation);
    }

    function scramble() {
        cube = new Cube();
        const scrambleMoves = cube.randomize();
        moveQueue = scrambleMoves.split(' ');
        setSolveInfo('Scrambling...');
        solveMode = true;
        executeNextMove();
        setTimeout(() => { solveMode = false; setSolveInfo(''); }, moveQueue.length * 400);
    }

    function solveCube() {
        if (solveMode) return;
        solveMode = true;
        setSolveInfo('Computing optimal solution...');
        document.getElementById('method-title').innerText = 'SOLVING (â‰¤22 MOVES)';
        setTimeout(() => {
            const solution = cube.solve(); // Kociemba optimal solution
            moveQueue = solution.trim().split(' ');
            setSolveInfo(`Executing solution (${moveQueue.length} moves)`);
            executeNextMove();
            setTimeout(() => {
                setSolveInfo('ðŸŽ‰ Solved!');
                document.getElementById('method-title').innerText = 'CONTROLS';
                setTimeout(() => { setSolveInfo(''); solveMode = false; }, 3000);
            }, moveQueue.length * 700 + 500);
        }, 100);
    }

    function setSolveInfo(text) {
        const el = document.getElementById('solve-info');
        el.textContent = text || '';
        el.style.opacity = text ? 1 : 0;
    }

    function resetCube() {
        location.reload();
    }

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
